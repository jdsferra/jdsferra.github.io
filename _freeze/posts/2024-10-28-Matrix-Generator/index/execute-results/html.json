{
  "hash": "64f46ccbc8e29ff96831ca768a996612",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Making a Twelve-Tone Matrix Generator in Python\"\ndescription: \"Recreating a tool I used in the music theory classroom with Python.\"\nauthor: Joe Sferra\ndate: 10-30-2024\ncategories: [Python, Music]\nimage: fullmatrix.jpg\ndraft: true\n---\n\n![](/posts/2024-10-28-Matrix-Generator/fullmatrix.jpg){width=50% height=50% fig-align=\"center\"}     \n\n## Meeting the Matrix\nThe twelve-tone matrix is a tool that most college music students have run into at least once in their lives during a music theory course. For a lot of them, it becomes the bane of their existence, as it relies on an understanding of math that they haven't used much. To add insult to injury, matrices are used for atonal music, the kind of music that isn't always pleasant to listen to! I thought that by coding a matrix generator out in Python, I could atone for subjecting so many of my former students to this technique and learn a little something myself.\n\nTo understand the matrix, we have to understand a little bit about music in the early twentieth century. At that time, musicians were reaching out to find new musical techniques to express themselves and their feelings about the world around them. Many felt adrift in the wake of conflicts like World War I, and to mirror that \"adrift-ness\" in their music, they abandoned the idea of tonality, or a central pitch that feels like \"home\" or the point of arrival in a piece of music. One technique they used to replace tonality (or to achieve \"atonality\") was to use a \"tone row\", a sequence of all 12 pitches in the chromatic scale, as their new \"home\". The tone row gave them the opportunity to make music with wild new sounds and harmonies, but also some kind of \"home\" (even if it's a whole lot harder to hear!). This row could be the basis for melodies, harmonies, and all the pitch decisions in a style of music that we call dodecaphonic, or 12-tone music.  \n\n**Ruth Crawford Seeger's String Quartet 1931 is a beautiful piece based on tone rows!**\n{{< video https://www.youtube.com/watch?v=JvbuUzDRVes>}}\n\n## Pitch Class Space\nThis isn't the place where we can learn all of the theory that we need to know to approach this, but I will try to hit a couple of the big concepts so that you can dip your toes in. Dodecaphonic music relies on two types of equivalence:  \n  \n#### Octave Equivalence  \nAn *F#* on a keyboard is an *F#* everywhere. Two notes that are the same, but in different octaves, are effectively the same in our analysis.  \nand\n    \n#### Enharmonic Equivalence     \nAn *F#* is the same as a *Gb*. Two notes that would be on the same spot on the keyboard, but are spelled differently, are effectively the same in our analysis.\n\nTaking these two assumptions together, atonal music now exists in **pitch class space**, a theoretical space like a clock's face. If you go above or below the range of 0 to 11, it flips back around into that range. If you go two past 11, you get 1. If you start moving below zero, say to -5, it flips back around to being 7.\n\n![](/posts/2024-10-28-Matrix-Generator/pitch_class_space_clock.jpg)\n\nSo before we start building our matrix, we need to put our numbers into pitch-class space. Think about this as the ground rules for our calculator. Here's a function in Python: \n\n::: {#bf4d725d .cell execution_count=1}\n``` {.python .cell-code}\ndef modconvert(num):\n  if num >= 0 and num < 12:\n    return num\n  else:\n    return num % 12\n\nfor num in range(-6, 0):\n  print(f\"{num} modconverts to {modconvert(num)}\")\nfor num in range(12, 19):\n  print(f\"{num} modconverts to {modconvert(num)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-6 modconverts to 6\n-5 modconverts to 7\n-4 modconverts to 8\n-3 modconverts to 9\n-2 modconverts to 10\n-1 modconverts to 11\n12 modconverts to 0\n13 modconverts to 1\n14 modconverts to 2\n15 modconverts to 3\n16 modconverts to 4\n17 modconverts to 5\n18 modconverts to 6\n```\n:::\n:::\n\n\nOk, so now we're in pitch class space! We're going to slap this conversion function on basically all the operations we do in the rest of the generator.\n\n## Row Forms  \nSo you may be thinking to yourself: \n\n> ***\"WHOA this music only uses one sequence of pitches the whole time? Wouldn't that get boring?\"***\n\nThe answer is **YES**.\nThat's why the twelve-tone matrix exists. It's a way to give one row a bunch of transformations to use as the basis of the composition. These transformations imitate similar techniques from earlier classical music: *transposition*, *inversion*, and *retrograde*.\n\n#### Prime, Inversion, Retrograde, Retrograde Inversion   \n*Prime forms* represent the original row, but transposed. The difference between the index numbers represents how many half steps the forms are away from each other. In the matrix, read left to right.    \n\n*Inversion forms* represent the original row, but inverted. If you measure the intervals of a prime row in pitch class space and then mirror them (go the opposite number of hours on the clock), you get the inversion forms. Read top to bottom.   \n\n*Retrograde* is Prime form read in reverse. Notice the numbering convention here. Read right to left.  \n\n*Retrograde Inversion* is the retrograde reading of the inversion. Read bottom to top. Note: not the inversion of the retrograde! \n\n#### Expressing Row Forms in Python  \nMy experience so far with learning data structures and algorithms is that you're always trying to get down to the fewest number of calculations that you can possibly use. Don't be inefficient. I really hope we don't have to do all 48 calculations for this thing! And in fact we don't! We're going to do 12 transpositions of the original row and have them printed out to represent the whole matrix.\n\nThis means we have to take a few steps in Python now. Let's say that we're going to take in a list of twelve integers as the prime row, numbered 0-11. We're going to need to transpose this row and measure by how far we have to transpose it.\n\nLet's do the first part, transposing a row.\n\n::: {#b8162011 .cell execution_count=2}\n``` {.python .cell-code}\n# Takes in a row and transposes every pitch class \n# by the same interval (opci- hours forward on the clock).\n# Prints how it should look in the matrix\n\ndef transpose_print (row, opci):\n    transposed = [modconvert(x + opci) for x in row]\n    \n    newrow = f'P{transposed[0]} {transposed} R{transposed[0]}'\n    \n    # Naming convention to tighten matrix's looks up\n    print(newrow.replace('10', 'T').replace('11', 'E'))\n\nmyrow = [2, 11, 6, 5, 4, 3, 0, 8, 9, 7, 1, 10]\ntranspose_print(myrow, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nP5 [5, 2, 9, 8, 7, 6, 3, E, 0, T, 4, 1] R5\n```\n:::\n:::\n\n\nOk, so this looks like most of the lines of our matrix, so we're getting close! We can express the matrix as a series of transpositions of the prime row. Now we need to measure by how far we have to transpose. I'm going to make a list called \"Torder\" or transposition order. It will be twelve numbers long, representing all the transpositions we'll need to do, and they will represent inversions of the intervals in the original row.\n\n**Before you look at the \"Torder\" function below, try to imagine what Torder will look like for myrow.**\n\n::: {#6f0240f8 .cell execution_count=3}\n``` {.python .cell-code}\nmyrow = [2, 11, 6, 5, 4, 3, 0, 8, 9, 7, 1, 10]\n\ndef make_torder(row):\n    # creates the list of intervals by which \n    # you need to transpose and print the prime row\n    # first el is always 0\n    Torder = [0]\n    \n    # append inversion of distance between each element and first element\n    for x in range(1,12):\n        i = modconvert(row[0] - row[x])\n        Torder.append(i)\n    \n    return Torder\n\ny = make_torder(myrow)\nprint(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0, 3, 8, 9, 10, 11, 2, 6, 5, 7, 1, 4]\n```\n:::\n:::\n\n\nFiguring out this order is a bit tougher, so don't worry if you don't have this totally down in your head yet.  \n\n## The Code Solution\n\n::: {#a6dd28c5 .cell execution_count=4}\n``` {.python .cell-code}\n# Helper functions we have built so far\ndef modconvert(num):\n  if num >= 0 and num < 12:\n    return num\n  else:\n    return num % 12\n\ndef transpose_print (row, opci):\n    transposed = [modconvert(x+opci) for x in row]\n    \n    newrow = f'P{transposed[0]} {transposed} R{transposed[0]}'\n    \n    # Naming convention to tighten matrix's looks up\n    print(newrow.replace('10', 'T').replace('11', 'E'))\n\ndef transpose_print (row, opci):\n    transposed = [modconvert(x+opci) for x in row]\n    \n    newrow = f'P{transposed[0]} {transposed} R{transposed[0]}'\n    \n    # Naming convention to tighten matrix's looks up\n    print(newrow.replace('10', 'T').replace('11', 'E'))\n    \ndef make_torder(row):\n    # creates the list of intervals by which \n    # you need to transpose and print the prime row\n    # first el is always 0\n    Torder = [0]\n    \n    # append inversion of distance between each element and first element\n    for x in range(1,12):\n        i = modconvert(row[0] - row[x])\n        Torder.append(i)\n    \n    return Torder\n\n# NEW- assembling helper functions\ndef generatematrix(row):\n  \n  # Make Torder\n  Torder = make_torder(row)\n  \n  # Printing Matrix\n  \n  print(f\"X  I{' I'.join(str(el) for el in row)} \\\n  X\".replace('10', 'T').replace('11', 'E'))\n  \n  for x in Torder:\n      transpose_print(row, x)\n      \n  print(f\"X  RI{'RI'.join(str(el) for el in row)}\\\n  X\".replace('10', 'T').replace('11', 'E'))\n\nif __name__ == \"__main__\":\n    myrow = [2, 11, 6, 5, 4, 3, 0, 8, 9, 7, 1, 10]\n    \n    generatematrix(myrow)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nX  I2 IE I6 I5 I4 I3 I0 I8 I9 I7 I1 IT   X\nP2 [2, E, 6, 5, 4, 3, 0, 8, 9, 7, 1, T] R2\nP5 [5, 2, 9, 8, 7, 6, 3, E, 0, T, 4, 1] R5\nPT [T, 7, 2, 1, 0, E, 8, 4, 5, 3, 9, 6] RT\nPE [E, 8, 3, 2, 1, 0, 9, 5, 6, 4, T, 7] RE\nP0 [0, 9, 4, 3, 2, 1, T, 6, 7, 5, E, 8] R0\nP1 [1, T, 5, 4, 3, 2, E, 7, 8, 6, 0, 9] R1\nP4 [4, 1, 8, 7, 6, 5, 2, T, E, 9, 3, 0] R4\nP8 [8, 5, 0, E, T, 9, 6, 2, 3, 1, 7, 4] R8\nP7 [7, 4, E, T, 9, 8, 5, 1, 2, 0, 6, 3] R7\nP9 [9, 6, 1, 0, E, T, 7, 3, 4, 2, 8, 5] R9\nP3 [3, 0, 7, 6, 5, 4, 1, 9, T, 8, 2, E] R3\nP6 [6, 3, T, 9, 8, 7, 4, 0, 1, E, 5, 2] R6\nX  RI2RIERI6RI5RI4RI3RI0RI8RI9RI7RI1RIT  X\n```\n:::\n:::\n\n\nThere you have it! Some places to take this next would be to make pitch class numbers and regular note spellings (like *Bb*) interchangeable, making a row class with transposition as a method, a way to check that your input row is a correct possible row, all kinds of things. But I hope that this was an interesting introduction. I've found combining my experience with music theory and coding to be very rewarding, so I want to thank you for reading this far!\n\n***Any questions? Want some more weird music recommendations?? Find me on LinkedIn!***\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}